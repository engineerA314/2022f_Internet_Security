인터넷보안 과제 1 준비

1. keygen
임의의 두 소수 p, q를 고르면 public e, n 과 private d를 생성해야 함

문제는 소수 p, q가 매우 크다는 것. (스펙에서는 1024 bit primes 으로 주어짐)
89884656743115795386465259539451236680898848947115328636715040578866337902750481566354238661203768010560056939935696678829394884407208311246423715319737062188883946712432742638151109800623047059726541476042502884419075341171231440736956555270413618581675255342293149119973622969239858152417678164812112069763

89884656743115795386465259539451236680898848947115328636715040578866337902750481566354238661203768010560056939935696678829394884407208311246423715319737062188883946712432742638151109800623047059726541476042502884419075341171231440736956555270413618581675255342293149119973622969239858152417678164812112070101


둘의 곱 n = pq 는 어쩔 수 없이 그냥 계산해야 할 듯
phi_n = (p -1) (q - 1) 도 그냥 계산해야 할듯

phi 이하의 gcd(e, phi_n) 을 구하는 것을 p-1 과 q-1 을 이용해서 빠르게 할 방법을 찾아야 하고
-> 천만 단위만 되어도 계산이 안 됨


phi_n 은 반드시 짝수, 따라서 e는 반드시 홀수
gcd(e, (p-1)(q-1))
두 짝수 p-1과 q-1 에 대해 e는 둘의 소인수가 아닌 소수이기만 하면 gcd가 0이 된다.
따라서 소수를 가장 작은 값부터 순회하면서 p-1과 q-1가 이 숫자로 나뉘어지는지를 확인하면 gcd를 할 필요가 없다?
-> 현재 이렇게 구현함. 근데 이러면 가장 작은 소수를 e로 고르는데 이게 적절한지 의문.
-> 랜덤이니까 e를 골랐을 때 d가 너무 커지거나 하지는 않나?

de % phi_n 이 1인 값을 구하는 것도 빠르게 할 수 있어야 함
-> 이거도 마찬가지일 것.
-> 이쪽이 EEA를 사용하는듯

2. encrypt
plaintext와 public key가 주어지면 암호화

p^e % n 인데, p와 e는 모두 n 이하이기 때문에 줄일 방법이 있는지 모르겠음

3. decrypt
ciphertext 와 private key가 주어지면 복호화

c ^ d % n = p 인데, c와 d 모두 n 이하라서 줄일 방법이 있는지 모르겠음




